import React, {useRef, useEffect, useState} from "react";
import * as d3 from "d3";

import { FrameRender } from './FrameRender.js';
import { VideoRender } from './VideoRender.js';

import Button from '@mui/material/Button';
import Checkbox from '@mui/material/Checkbox';
import Dialog from '@mui/material/Dialog';
import DialogActions from '@mui/material/DialogActions';
import DialogContent from '@mui/material/DialogContent';
import DialogContentText from '@mui/material/DialogContentText';
import DialogTitle from '@mui/material/DialogTitle';
import FormGroup from '@mui/material/FormGroup';
import FormControlLabel from '@mui/material/FormControlLabel';

export const SegmentSelector = ({image=[],
								segmentation=[],
								segMap={},
								setSegments,
								isVideo=false,
								_selection}) => {

	const [uniqueSegments, setUniqueSegments] = useState([]);
	const [selectedSegments, setSelectedSegments] = useState(new Set());
	const [overlay, setOverlay] = useState(segmentation);

	const [open, setOpen] = useState(false);

	let segmentColorScale = d3.scaleOrdinal(d3.schemeTableau10)
		 					  .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

	// const [segmentColor, setSegmentColor] = useState(() => segmentColorScale);

	useEffect(() => {

		if (isVideo) {
			let newUniqueSegments = Array.from(new Set(segmentation[0].flat())).filter(segNum => segNum != 0);
			newUniqueSegments.sort((a, b) => a - b);
			setUniqueSegments(newUniqueSegments);
			setSelectedSegments(new Set(newUniqueSegments));
		} else {
			let newUniqueSegments = Array.from(new Set(segmentation.flat())).filter(segNum => segNum != 0);
			newUniqueSegments.sort((a, b) => a - b);
			setUniqueSegments(newUniqueSegments);
			setSelectedSegments(new Set(newUniqueSegments));
		}

		// let newSegmentColorScale = d3.scaleOrdinal(d3.schemeGnBu[newUniqueSegments.length + 2].slice(2,))
		//  					.domain(newUniqueSegments);

		// setSegmentColor(() => newSegmentColorScale);

	}, [])

	useEffect(() => {

		if (isVideo) {
			let newOverlay = [];

			for (let frame of segmentation) {
				let newFrame = frame.map(row => row.map(cell => selectedSegments.has(cell) ? cell : 0));
				newOverlay.push(newFrame);
			}

			setOverlay([...newOverlay]);
		} else {
			let newOverlay = segmentation.map(row => row.map(cell => selectedSegments.has(cell) ? cell : 0));
			setOverlay([...newOverlay]);
		}

	}, [selectedSegments])

	function toggleCheckbox(s) {

		let newSelectedSegments;

		if (selectedSegments.has(s)) {
			selectedSegments.delete(s);
			newSelectedSegments = new Set(selectedSegments);
		} else {
			selectedSegments.add(s);
			newSelectedSegments = new Set(selectedSegments);
		}

		setSelectedSegments(newSelectedSegments);

		setSegments(Array.from(newSelectedSegments));
	}

	// function startRecombine() {
	// 	let hidden = document.getElementById(_selection);
	//     let selection = JSON.stringify(Array.from(selectedSegments));

	//     if (hidden) {
	//         hidden.value = selection;
	//         var event = document.createEvent('HTMLEvents');
	//         event.initEvent('input', false, true);
	//         hidden.dispatchEvent(event);
	//     }

	//     handleClose();
	// }

	function handleClose() {
		setOpen(false);
	}

	function handleOpen() {
		setOpen(true);
	}

	let selectorLayout = {"display": "flex", "marginBottom":"20px", "marginLeft":"10px"};
	let recombineButton = {"marginTop": "15px"};
	let controls = {"minWidth": "200px", "maxWidth": "250px", "margin": "0px 20px 0px 0px"};

	return (
		<div style={selectorLayout}>
			<FormGroup style={controls}>
				{uniqueSegments.map((seg, i) => <FormControlLabel key={i} control={<Checkbox defaultChecked style={{color: segmentColorScale(seg)}} onChange={() => toggleCheckbox(seg)} />} label={segMap[seg] ? segMap[seg] : seg} />)}
				{/*<Button style={recombineButton} variant="outlined" onClick={handleOpen}>
					Recombine
				</Button>*/}
	    	</FormGroup>
	    	{isVideo
	    		? <VideoRender images={image} overlays={overlay} />
	    		: <FrameRender image={image} overlay={overlay} />
	    	}
	    	{/*<Dialog
		        open={open}
		        onClose={handleClose}
		        aria-labelledby="alert-dialog-title"
		        aria-describedby="alert-dialog-description"
		    >
		        <DialogTitle id="alert-dialog-title">
		        	{"Generate Counterfactuals"}
		        </DialogTitle>
		        <DialogContent>
					<DialogContentText id="alert-dialog-description">
					{`Recombinant counterfactual images will be generated by replacing the selected segments (${Array.from(selectedSegments).map(item => segMap[item] ? segMap[item] : item).join(", ")}) in the target image with corresponding images in the filtered subset.`}
					</DialogContentText>
		        </DialogContent>
		        <DialogActions>
					<Button onClick={handleClose}>Close</Button>
					<Button onClick={startRecombine} autoFocus>
					Confirm
					</Button>
		        </DialogActions>
		    </Dialog>*/}
		</div>
	)

}